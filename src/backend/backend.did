type AccessCondition = variant {
  Immediate;
  EventTriggered : record { event : AccessEvent };
  Scheduled : record { accessible_after : nat64 };
  ExpiresAt : record { expires : nat64 };
};
type AccessEntry = record {
  id : text;
  is_public : bool;
  updated_at : nat64;
  role : ResourceRole;
  source_id : opt text;
  created_at : nat64;
  person_ref : opt PersonRef;
  invited_by_person_ref : opt PersonRef;
  grant_source : GrantSource;
  perm_mask : nat32;
  condition : AccessCondition;
};
type AccessEvent = variant {
  CapsuleMaturity : nat32;
  Graduation;
  AfterDeath;
  Wedding;
  Birthday : nat32;
  Custom : text;
  ConnectionCount : nat32;
  Anniversary : nat32;
};
type AssetCleanupResult = record {
  assets_cleaned : nat32;
  memory_id : text;
  message : text;
};
type AssetMetadata = variant {
  Note : NoteAssetMetadata;
  Image : ImageAssetMetadata;
  Document : DocumentAssetMetadata;
  Audio : AudioAssetMetadata;
  Video : VideoAssetMetadata;
};
type AssetMetadataBase = record {
  url : opt text;
  height : opt nat32;
  updated_at : nat64;
  asset_type : AssetType;
  sha256 : opt blob;
  name : text;
  storage_key : opt text;
  tags : vec text;
  processing_error : opt text;
  mime_type : text;
  description : opt text;
  created_at : nat64;
  deleted_at : opt nat64;
  bytes : nat64;
  asset_location : opt text;
  width : opt nat32;
  processing_status : opt text;
  bucket : opt text;
};
type AssetRemovalResult = record {
  memory_id : text;
  asset_removed : bool;
  message : text;
};
type AssetType = variant { Preview; Metadata; Derivative; Original; Thumbnail };
type AudioAssetMetadata = record {
  duration : opt nat64;
  base : AssetMetadataBase;
  codec : opt text;
  channels : opt nat8;
  sample_rate : opt nat32;
  bit_depth : opt nat8;
  bitrate : opt nat64;
};
type BackendHosting = variant { Icp; Vercel };
type BlobHosting = variant { S3; Icp; VercelBlob; Ipfs; Neon; Arweave };
type BlobMeta = record { size : nat64; chunk_count : nat32 };
type BlobRef = record { len : nat64; locator : text; hash : opt blob };
type BulkDeleteResult = record {
  deleted_count : nat32;
  message : text;
  failed_count : nat32;
};
type BulkFailure = record { id : text; err : Error };
type BulkResult = record { ok : vec text; failed : vec BulkFailure };
type CanisterSizeStats = record {
  remaining_capacity_bytes : nat64;
  max_size_bytes : nat64;
  total_size_bytes : nat64;
  usage_percentage : float64;
};
type Capsule = record {
  id : text;
  updated_at : nat64;
  has_advanced_settings : bool;
  controllers : vec record { PersonRef; ControllerState };
  subject : PersonRef;
  owners : vec record { PersonRef; OwnerState };
  inline_bytes_used : nat64;
  folders : vec record { text; Folder };
  created_at : nat64;
  connection_groups : vec record { text; ConnectionGroup };
  connections : vec record { PersonRef; Connection };
  memories : vec record { text; Memory };
  bound_to_neon : bool;
  galleries : vec record { text; Gallery };
  hosting_preferences : HostingPreferences;
};
type CapsuleHeader = record {
  id : text;
  updated_at : nat64;
  subject : PersonRef;
  owner_count : nat64;
  created_at : nat64;
  controller_count : nat64;
  memory_count : nat64;
};
type CapsuleInfo = record {
  updated_at : nat64;
  gallery_count : nat64;
  subject : PersonRef;
  capsule_id : text;
  is_owner : bool;
  created_at : nat64;
  bound_to_neon : bool;
  memory_count : nat64;
  connection_count : nat64;
  is_self_capsule : bool;
  is_controller : bool;
};
type CapsuleUpdateData = record { bound_to_neon : opt bool };
type Connection = record {
  status : ConnectionStatus;
  updated_at : nat64;
  peer : PersonRef;
  created_at : nat64;
};
type ConnectionGroup = record {
  id : text;
  updated_at : nat64;
  members : vec PersonRef;
  name : text;
  description : opt text;
  created_at : nat64;
};
type ConnectionStatus = variant { Blocked; Accepted; Revoked; Pending };
type ControllerState = record { granted_at : nat64; granted_by : PersonRef };
type CreationStatus = variant {
  Importing;
  Creating;
  Failed;
  Exporting;
  Installing;
  Completed;
  Verifying;
  NotStarted;
};
type CreationStatusResponse = record {
  status : CreationStatus;
  canister_id : opt principal;
  message : opt text;
};
type DatabaseHosting = variant { Icp; Neon };
type DetailedCreationStatus = record {
  status : CreationStatus;
  progress_message : text;
  canister_id : opt principal;
  error_message : opt text;
  created_at : nat64;
  cycles_consumed : nat;
  completed_at : opt nat64;
};
type DocumentAssetMetadata = record {
  document_type : opt text;
  base : AssetMetadataBase;
  language : opt text;
  page_count : opt nat32;
  word_count : opt nat32;
};
type Error = variant {
  Internal : text;
  NotFound;
  Unauthorized;
  InvalidArgument : text;
  ResourceExhausted;
  NotImplemented : text;
  Conflict : text;
};
type Folder = record {
  id : text;
  updated_at : nat64;
  capsule_id : text;
  metadata : FolderMetadata;
  created_at : nat64;
  access_entries : vec AccessEntry;
};
type FolderData = record { folder : Folder };
type FolderHeader = record {
  id : text;
  total_memories : nat32;
  title : opt text;
  updated_at : nat64;
  sharing_status : SharingStatus;
  storage_location : vec BlobHosting;
  name : text;
  created_at : nat64;
  memory_count : nat64;
  shared_count : nat32;
};
type FolderMetadata = record {
  total_memories : nat32;
  title : opt text;
  sharing_status : SharingStatus;
  storage_location : vec BlobHosting;
  name : text;
  description : opt text;
  shared_count : nat32;
};
type FolderUpdateData = record { title : opt text; description : opt text };
type Gallery = record {
  id : text;
  updated_at : nat64;
  capsule_id : text;
  metadata : FolderMetadata;
  cover_memory_id : opt text;
  created_at : nat64;
  items : vec GalleryItem;
  access_entries : vec AccessEntry;
};
type GalleryData = record { owner_principal : principal; gallery : Gallery };
type GalleryItem = record {
  memory_type : MemoryType;
  metadata : vec record { text; text };
  memory_id : text;
  caption : opt text;
  position : nat32;
};
type GalleryMemoryEntry = record {
  memory_id : text;
  is_featured : bool;
  position : nat32;
  gallery_metadata : text;
  gallery_caption : opt text;
};
type GalleryMetadata = record {
  total_memories : nat32;
  title : opt text;
  sharing_status : SharingStatus;
  storage_location : vec BlobHosting;
  name : text;
  description : opt text;
  shared_count : nat32;
};
type GallerySizeInfo = record {
  total_size_bytes : nat64;
  memory_count : nat64;
  metadata_size : nat64;
  average_memory_size : nat64;
};
type GalleryUpdateData = record {
  is_public : opt bool;
  title : opt text;
  memory_entries : opt vec GalleryMemoryEntry;
  description : opt text;
};
type GrantSource = variant { MagicLink; System; Group; User };
type HostingPreferences = record {
  backend_hosting : BackendHosting;
  database_hosting : DatabaseHosting;
  blob_hosting : BlobHosting;
  frontend_hosting : BackendHosting;
};
type HttpRequest = record {
  url : text;
  method : text;
  body : blob;
  headers : vec record { text; text };
  certificate_version : opt nat16;
};
type HttpResponse = record {
  body : blob;
  headers : vec record { text; text };
  upgrade : opt bool;
  status_code : nat16;
};
type ImageAssetMetadata = record {
  dpi : opt nat32;
  color_space : opt text;
  base : AssetMetadataBase;
  exif_data : opt text;
  compression_ratio : opt float32;
  orientation : opt nat8;
};
type InlineAssetInput = record { metadata : AssetMetadata; bytes : blob };
type InternalBlobAssetInput = record {
  metadata : AssetMetadata;
  blob_id : text;
};
type Memory = record {
  id : text;
  inline_assets : vec MemoryAssetInline;
  capsule_id : text;
  metadata : MemoryMetadata;
  blob_internal_assets : vec MemoryAssetBlobInternal;
  blob_external_assets : vec MemoryAssetBlobExternal;
  access_entries : vec AccessEntry;
};
type MemoryAssetBlobExternal = record {
  url : opt text;
  metadata : AssetMetadata;
  storage_key : text;
  asset_id : text;
  location : BlobHosting;
};
type MemoryAssetBlobInternal = record {
  metadata : AssetMetadata;
  blob_ref : BlobRef;
  asset_id : text;
};
type MemoryAssetData = variant {
  ExternalUrl : record { url : text; sha256 : opt blob; size : opt nat64 };
  Inline : record {
    sha256 : opt blob;
    size : nat64;
    content_type : text;
    bytes : blob;
  };
  InternalBlob : record { sha256 : opt blob; blob_id : text; size : nat64 };
};
type MemoryAssetInline = record {
  metadata : AssetMetadata;
  bytes : blob;
  asset_id : text;
};
type MemoryAssetsList = record {
  inline_assets : vec text;
  internal_assets : vec text;
  external_assets : vec text;
  memory_id : text;
  total_count : nat32;
};
type MemoryHeader = record {
  id : text;
  title : opt text;
  updated_at : nat64;
  sharing_status : SharingStatus;
  capsule_id : text;
  memory_type : MemoryType;
  name : text;
  size : nat64;
  tags : vec text;
  has_thumbnails : bool;
  has_previews : bool;
  database_storage_edges : vec DatabaseHosting;
  description : opt text;
  created_at : nat64;
  thumbnail_url : opt text;
  parent_folder_id : opt text;
  asset_count : nat32;
  primary_asset_url : opt text;
  shared_count : nat32;
};
type MemoryMetadata = record {
  title : opt text;
  updated_at : nat64;
  sharing_status : SharingStatus;
  date_of_memory : opt nat64;
  memory_type : MemoryType;
  tags : vec text;
  has_thumbnails : bool;
  content_type : text;
  people_in_memory : opt vec text;
  has_previews : bool;
  database_storage_edges : vec DatabaseHosting;
  description : opt text;
  created_at : nat64;
  created_by : opt text;
  total_size : nat64;
  thumbnail_url : opt text;
  parent_folder_id : opt text;
  asset_count : nat32;
  deleted_at : opt nat64;
  primary_asset_url : opt text;
  shared_count : nat32;
  file_created_at : opt nat64;
  location : opt text;
  memory_notes : opt text;
  uploaded_at : nat64;
};
type MemoryPresenceResult = record {
  metadata_present : bool;
  memory_id : text;
  asset_present : bool;
};
type MemoryType = variant { Note; Image; Document; Audio; Video };
type MemoryUpdateData = record {
  metadata : opt MemoryMetadata;
  name : opt text;
  access_entries : opt vec AccessEntry;
};
type NoteAssetMetadata = record {
  base : AssetMetadataBase;
  language : opt text;
  word_count : opt nat32;
  format : opt text;
};
type OwnerState = record { last_activity_at : nat64; since : nat64 };
type Page = record { next_cursor : opt text; items : vec MemoryHeader };
type PersonRef = variant { Opaque : text; Principal : principal };
type PersonalCanisterCreationResponse = record {
  canister_id : opt principal;
  message : text;
  success : bool;
};
type PersonalCanisterCreationStats = record {
  total_successes : nat64;
  total_failures : nat64;
  total_attempts : nat64;
  total_cycles_consumed : nat;
};
type ResourceRole = variant { Guest; Member; SuperAdmin; Admin; Owner };
type ResourceType = variant { Memory; Capsule; Gallery };
type Result = variant { Ok; Err : Error };
type Result13 = variant { Ok : nat64; Err : Error };
type Result14 = variant { Ok : principal; Err : Error };
type Result15 = variant { Ok : UploadFinishResult; Err : Error };
type Result6 = variant { Ok : text; Err : Error };
type Result_1 = variant { Ok : MemoryAssetData; Err : Error };
type Result_10 = variant {
  Ok : vec record { principal; DetailedCreationStatus };
  Err : Error;
};
type Result_11 = variant { Ok : PersonalCanisterCreationStats; Err : Error };
type Result_12 = variant { Ok : opt DetailedCreationStatus; Err : Error };
type Result_13 = variant { Ok : UserSettingsResponse; Err : Error };
type Result_14 = variant { Ok : AssetCleanupResult; Err : Error };
type Result_15 = variant { Ok : BulkResult; Err : Error };
type Result_16 = variant { Ok : BulkDeleteResult; Err : Error };
type Result_17 = variant { Ok : Page; Err : Error };
type Result_18 = variant { Ok : MemoryAssetsList; Err : Error };
type Result_19 = variant { Ok : vec MemoryPresenceResult; Err : Error };
type Result_2 = variant { Ok : AssetRemovalResult; Err : Error };
type Result_20 = variant { Ok : Memory; Err : Error };
type Result_3 = variant { Ok : BlobMeta; Err : Error };
type Result_4 = variant { Ok : blob; Err : Error };
type Result_5 = variant { Ok : Capsule; Err : Error };
type Result_6 = variant { Ok : CapsuleInfo; Err : Error };
type Result_7 = variant { Ok : bool; Err : Error };
type Result_8 = variant { Ok : Folder; Err : Error };
type Result_9 = variant { Ok : Gallery; Err : Error };
type SharingStatus = variant { Shared; Private; Public };
type StorageBackend = variant { S3; Icp; VercelBlob; Ipfs; Arweave };
type UploadConfig = record {
  inline_max : nat32;
  chunk_size : nat32;
  inline_budget_per_capsule : nat32;
};
type UploadFinishResult = record {
  checksum_sha256 : opt blob;
  storage_location : text;
  blob_id : text;
  storage_backend : StorageBackend;
  size : nat64;
  memory_id : text;
  remote_id : opt text;
  expires_at : opt nat64;
  uploaded_at : nat64;
};
type UserSettingsResponse = record {
  has_advanced_settings : bool;
  hosting_preferences : HostingPreferences;
};
type UserSettingsUpdateData = record { has_advanced_settings : opt bool };
type VideoAssetMetadata = record {
  duration : opt nat64;
  base : AssetMetadataBase;
  codec : opt text;
  frame_rate : opt float32;
  resolution : opt text;
  bitrate : opt nat64;
  aspect_ratio : opt float32;
};
service : () -> {
  _probe_inline_len : (opt blob) -> (nat64, blob);
  add_admin : (principal) -> (Result);
  // Get a specific asset from a memory by asset_id
  asset_get_by_id : (text, text) -> (Result_1) query;
  // Remove a specific asset from a memory by asset reference
  asset_remove : (text, text) -> (Result_2);
  // Remove a specific asset from a memory by asset_id
  asset_remove_by_id : (text, text) -> (Result_2);
  // Remove specific external storage asset by storage key
  asset_remove_external : (text, text) -> (Result_2);
  // Remove specific inline asset by index
  asset_remove_inline : (text, nat32) -> (Result_2);
  // Remove specific ICP blob asset by blob reference
  asset_remove_internal : (text, text) -> (Result_2);
  // Delete blob by ID (unified endpoint for all blob types)
  blob_delete : (text) -> (Result6);
  // Get blob metadata including total chunk count
  blob_get_meta : (text) -> (Result_3) query;
  // Read blob data by locator (for asset retrieval)
  blob_read : (text) -> (Result_4) query;
  // Read blob data by locator in chunks (for large files)
  // Returns individual chunks to avoid IC message size limits
  blob_read_chunk : (text, nat32) -> (Result_4) query;
  // Calculate gallery size when stored in capsule context
  calculate_gallery_capsule_size : (Gallery) -> (nat64) query;
  // Calculate just the gallery size (without capsule overhead)
  calculate_gallery_size : (Gallery) -> (nat64) query;
  capsules_bind_neon : (ResourceType, text, bool) -> (Result);
  capsules_create : (opt PersonRef) -> (Result_5);
  capsules_delete : (text) -> (Result);
  capsules_list : () -> (vec CapsuleHeader) query;
  capsules_read_basic : (opt text) -> (Result_6) query;
  capsules_read_full : (opt text) -> (Result_5) query;
  capsules_update : (text, CapsuleUpdateData) -> (Result_5);
  // Emergency function to clear all stable memory data
  // WARNING: This will delete all stored data and should only be used for recovery
  clear_all_stable_memory : () -> (Result);
  clear_creation_state : (principal) -> (Result_7);
  clear_migration_state : (principal) -> (Result_7);
  create_personal_canister : () -> (PersonalCanisterCreationResponse);
  debug_blob_read_canary : (text, nat32) -> (opt nat32) query;
  debug_blob_write_canary : (text, nat32, nat32) -> ();
  // Debug endpoint to finish upload with hex hash (dev only)
  debug_finish_hex : (nat64, text, nat64) -> (Result6);
  // Debug endpoint to upload chunk with base64 data (dev only)
  debug_put_chunk_b64 : (nat64, nat32, text) -> (Result);
  // Debug endpoint to compute SHA256 hash of provided bytes
  debug_sha256 : (blob) -> (text) query;
  folders_create : (FolderData) -> (Result_8);
  folders_delete : (text) -> (Result);
  folders_list : () -> (vec FolderHeader) query;
  folders_update : (text, FolderUpdateData) -> (Result_8);
  galleries_create : (GalleryData) -> (Result_9);
  galleries_create_with_memories : (GalleryData, bool) -> (Result_9);
  galleries_delete : (text) -> (Result);
  galleries_list : () -> (vec FolderHeader) query;
  galleries_read : (text) -> (Result_9) query;
  galleries_update : (text, GalleryUpdateData) -> (Result_9);
  get_canister_size_stats : () -> (CanisterSizeStats) query;
  get_creation_states_by_status : (CreationStatus) -> (Result_10) query;
  get_creation_status : () -> (opt CreationStatusResponse) query;
  get_detailed_creation_status : () -> (opt DetailedCreationStatus) query;
  get_detailed_migration_status : () -> (opt DetailedCreationStatus) query;
  // Get detailed gallery size breakdown
  get_gallery_size_breakdown : (Gallery) -> (GallerySizeInfo) query;
  // Get gallery size information for debugging stable memory limits
  get_gallery_size_info : (Gallery) -> (text) query;
  get_migration_states_by_status : (CreationStatus) -> (Result_10) query;
  get_migration_stats : () -> (Result_11) query;
  get_migration_status : () -> (opt CreationStatusResponse) query;
  get_my_personal_canister_id : () -> (opt principal) query;
  get_personal_canister_creation_stats : () -> (Result_11) query;
  get_personal_canister_id : (principal) -> (opt principal) query;
  get_user_creation_status : (principal) -> (Result_12) query;
  get_user_migration_status : (principal) -> (Result_12) query;
  get_user_settings : () -> (Result_13) query;
  greet : (text) -> (text) query;
  http_request : (HttpRequest) -> (HttpResponse) query;
  is_migration_enabled : () -> (Result_7) query;
  is_personal_canister_creation_enabled : () -> (Result_7) query;
  list_admins : () -> (vec principal) query;
  list_all_creation_states : () -> (Result_10) query;
  list_all_migration_states : () -> (Result_10) query;
  list_superadmins : () -> (vec principal) query;
  memories_add_asset : (text, InternalBlobAssetInput, text) -> (Result6);
  memories_add_inline_asset : (text, InlineAssetInput, text) -> (Result6);
  // Clean up all assets from a memory while preserving the memory record
  memories_cleanup_assets_all : (text) -> (Result_14);
  // Bulk cleanup assets from multiple memories
  memories_cleanup_assets_bulk : (vec text) -> (Result_15);
  memories_create : (
      text,
      opt blob,
      opt BlobRef,
      opt BlobHosting,
      opt text,
      opt text,
      opt nat64,
      opt blob,
      AssetMetadata,
      text,
    ) -> (Result6);
  memories_create_with_internal_blobs : (
      text,
      MemoryMetadata,
      vec InternalBlobAssetInput,
      text,
    ) -> (Result6);
  memories_delete : (text, bool) -> (Result);
  // Delete ALL memories in a capsule (high-risk operation)
  memories_delete_all : (text, bool) -> (Result_16);
  // Bulk delete multiple memories in a single operation
  memories_delete_bulk : (text, vec text, bool) -> (Result_16);
  memories_list : (text, opt text, opt nat32) -> (Result_17) query;
  // List all assets in a memory
  memories_list_assets : (text) -> (Result_18) query;
  // List memories filtered by capsule_id field (for UUID v7 implementation)
  memories_list_by_capsule : (text, opt text, opt nat32) -> (Result_17) query;
  // Check presence for multiple memories on ICP (consolidated from get_memory_presence_icp and get_memory_list_presence_icp)
  memories_ping : (vec text) -> (Result_19) query;
  memories_read : (text) -> (Result_20) query;
  memories_read_asset : (text, nat32) -> (Result_1) query;
  memories_update : (text, MemoryUpdateData) -> (Result_20);
  migrate_capsule : () -> (PersonalCanisterCreationResponse);
  mint_http_token : (text, vec text, opt vec text, nat32) -> (text) query;
  register_with_nonce : (text) -> (Result);
  remove_admin : (principal) -> (Result);
  // Clean up expired sessions
  sessions_cleanup_expired : () -> (Result6);
  // Clear all upload sessions (development/debugging only)
  sessions_clear_all : () -> (Result6);
  // List all sessions for debugging
  sessions_list : () -> (Result6) query;
  // Get session statistics for monitoring
  sessions_stats : () -> (Result6) query;
  set_migration_enabled : (bool) -> (Result);
  set_personal_canister_creation_enabled : (bool) -> (Result);
  update_gallery_storage_location : (text, vec BlobHosting) -> (Result);
  update_user_settings : (UserSettingsUpdateData) -> (Result_13);
  // Get upload configuration for TypeScript client discoverability
  upload_config : () -> (UploadConfig) query;
  // Abort upload session and cleanup
  uploads_abort : (nat64) -> (Result);
  // Begin chunked upload for large files
  uploads_begin : (text, nat32, text) -> (Result13);
  // Commit chunks to create final memory
  uploads_finish : (nat64, blob, nat64) -> (Result15);
  // Upload a chunk for an active session
  uploads_put_chunk : (nat64, nat32, blob) -> (Result);
  verify_nonce : (text) -> (Result14) query;
  whoami : () -> (principal) query;
}
