# ICP-First User Architecture

**Status:** Open Issue  
**Priority:** Low (Future Enhancement)  
**Created:** January 2025  
**Type:** Architecture Design

## Overview

Design and implement an ICP-first user architecture where users primarily exist on the Internet Computer with optional Web2 synchronization. This represents a fundamental shift from Web2-first to Web3-first user management.

## Current Architecture

### Overview

```
User Registration → AuthJS → Neon DB → Optional ICP Integration
```

### Authentication Providers

Our system supports **dual authentication** with three providers:

1. **Google OAuth** - Primary Web2 authentication
2. **GitHub OAuth** - Alternative Web2 authentication
3. **Internet Identity (II)** - ICP blockchain authentication
4. **Credentials** - Email/password authentication

### Database Schema

#### Users Table (`users`)

```sql
CREATE TABLE users (
  id TEXT PRIMARY KEY,                    -- UUID generated by crypto.randomUUID()
  name TEXT,                              -- User display name
  email TEXT UNIQUE,                      -- Email (can be NULL for II users)
  emailVerified TIMESTAMP,                -- Email verification timestamp
  image TEXT,                             -- Profile image URL
  password TEXT,                          -- Hashed password (credentials only)
  username TEXT UNIQUE,                   -- Username
  role TEXT DEFAULT 'user',               -- user|moderator|admin|developer|superadmin
  userType TEXT DEFAULT 'personal',       -- personal|professional
  plan TEXT DEFAULT 'free',               -- free|premium
  createdAt TIMESTAMP DEFAULT NOW(),
  updatedAt TIMESTAMP DEFAULT NOW()
);
```

#### Accounts Table (`accounts`) - NextAuth.js

```sql
CREATE TABLE accounts (
  userId TEXT NOT NULL,                   -- FK to users.id
  type TEXT NOT NULL,                     -- oauth|oidc|credentials
  provider TEXT NOT NULL,                 -- google|github|internet-identity|credentials
  providerAccountId TEXT NOT NULL,        -- Google ID|GitHub ID|ICP Principal|email
  refresh_token TEXT,                     -- OAuth refresh token
  access_token TEXT,                      -- OAuth access token
  expires_at INTEGER,                     -- Token expiration
  -- ... other OAuth fields
  PRIMARY KEY (provider, providerAccountId) -- Prevents duplicate accounts
);
```

### Authentication Flow Values

#### Google Authentication

- **Provider**: `"google"`
- **ProviderAccountId**: Google's `sub` (subject) field
- **Type**: `"oauth"`
- **User ID**: Google's `sub` value
- **Email**: Google profile email
- **Name**: Google profile name

#### Internet Identity Authentication

- **Provider**: `"internet-identity"`
- **ProviderAccountId**: ICP Principal (e.g., `"rdmx6-jaaaa-aaaah-qcaiq-cai"`)
- **Type**: `"oidc"`
- **User ID**: Generated UUID (not the principal)
- **Email**: `NULL` (II users don't have email)
- **Name**: `NULL` (II users don't have name)

#### Credentials Authentication

- **Provider**: `"credentials"`
- **ProviderAccountId**: User's email address
- **Type**: `"credentials"`
- **User ID**: Generated UUID
- **Email**: User-provided email
- **Name**: User-provided name

### Dual Authentication Support

The system supports **account linking** where users can authenticate with multiple providers:

1. **User registers with Google** → Creates user record + Google account record
2. **User later links Internet Identity** → Adds II account record to existing user
3. **User can now sign in with either method** → Both point to same user record

### Key Implementation Details

- **One User, Multiple Accounts**: A single user can have multiple account records (Google + II)
- **Principal Persistence**: ICP Principal is stored in `accounts.providerAccountId` for II provider
- **Session Management**: NextAuth.js handles session creation and JWT token management
- **Account Linking**: Automatic linking based on existing account lookups

### Dual Authentication Capabilities

Our architecture supports **dual authentication** where users can authenticate with multiple providers while maintaining a single user identity:

#### **Account Linking Process**

When a user signs in with a second provider (e.g., Google user adds Internet Identity):

1. **No new user created** - Existing user record remains unchanged
2. **New account record added** - Additional authentication method linked to same user
3. **Both methods work** - User can sign in with either Google or Internet Identity

#### **Example: Google User Adds Internet Identity**

```
Before II Sign-in:
- users table: 1 record (Google user)
- accounts table: 1 record (Google account)

After II Sign-in:
- users table: 1 record (same Google user, unchanged)
- accounts table: 2 records (Google account + NEW Internet Identity account)
```

#### **Functional Implications**

**Google-Only User:**

- ✅ Can use all Web2 features
- ❌ Cannot store memories on ICP (requires ICP Principal)
- ❌ Cannot use ICP-specific features

**Google + Internet Identity User:**

- ✅ Can use all Web2 features (via Google authentication)
- ✅ Can store memories on ICP (via ICP Principal)
- ✅ Can use both Web2 and ICP features seamlessly
- ✅ Can sign in with either Google or Internet Identity

#### **ICP Operations Requirements**

- **ICP Memory Storage**: Requires Internet Identity authentication (ICP Principal)
- **ICP Canister Operations**: Requires Internet Identity authentication
- **Web2 Features**: Can use either Google or Internet Identity authentication
- **Cross-Platform Features**: Requires both authentication methods linked

This dual authentication system allows users to:

1. **Start with Web2** (Google/GitHub) for immediate access
2. **Add ICP capabilities** (Internet Identity) when needed for ICP features
3. **Maintain single identity** across both Web2 and Web3 ecosystems

## Proposed Architecture

```
User Registration → Internet Identity → ICP Backend → Optional Neon Sync
```

## Key Benefits

### 1. **Privacy by Design**

- Users can exist purely on ICP without any Web2 footprint
- Only sync to Neon when they explicitly choose to interact with Web2 features
- Principal-based identity is inherently more private than email-based

### 2. **Unified Identity System**

- Single source of truth: ICP Principal
- UUID as a bridge between ICP and Web2 worlds
- Users can seamlessly move between ICP and Web2 features

### 3. **Reduced Complexity**

- Skip AuthJS for ICP-native users
- Simpler authentication flow
- Less dependency on external auth providers

## Technical Implementation

### ICP Backend User Registry

```rust
#[derive(candid::CandidType, candid::Deserialize, Clone, Debug)]
pub struct User {
    pub principal: Principal,           // Primary identity
    pub uuid: String,                  // Bridge to Web2
    pub created_at: u64,
    pub web2_sync_enabled: bool,       // Opt-in for Web2 features
    pub web2_sync_data: Option<Web2SyncData>,
}

#[derive(candid::CandidType, candid::Deserialize, Clone, Debug)]
pub struct Web2SyncData {
    pub neon_user_id: Option<String>,
    pub last_sync: u64,
    pub sync_preferences: SyncPreferences,
}

// User registry in ICP
let users: StableBTreeMap<Principal, User> = StableBTreeMap::init(
    memory_manager.get_memory(),
    MemoryId::new(0),
);
```

### Neon Database Schema

```sql
-- Unified user table
CREATE TABLE users (
    id UUID PRIMARY KEY,                    -- Bridge identifier
    icp_principal TEXT UNIQUE,              -- ICP identity
    web2_email TEXT,                        -- Optional Web2 email
    created_at TIMESTAMP,
    web2_sync_enabled BOOLEAN DEFAULT false,
    -- ... other fields
);

-- Index for fast ICP principal lookups
CREATE INDEX idx_users_icp_principal ON users(icp_principal);
```

## User Journey Examples

### Pure ICP User

1. User connects with Internet Identity
2. Gets ICP Principal + UUID
3. Uses only ICP features (capsules, memories, etc.)
4. Never appears in Web2 database

### Hybrid User

1. User connects with Internet Identity
2. Gets ICP Principal + UUID
3. Opts into Web2 features
4. UUID gets synced to Neon database
5. Can use both ICP and Web2 features seamlessly

### Web2 User (Existing)

1. User registers with email/password
2. Gets UUID in Neon database
3. Can optionally connect ICP Principal later
4. Maintains backward compatibility

## Implementation Phases

### Phase 1: ICP-First Registration

- Implement Internet Identity authentication
- Create ICP user registry
- Generate UUIDs for all ICP users
- Basic user management functions

### Phase 2: Optional Web2 Sync

- Add opt-in Web2 synchronization
- Implement bidirectional sync between ICP and Neon
- Privacy controls for data sharing

### Phase 3: Migration Tools

- Tools to migrate existing Web2 users
- Data migration scripts
- Backward compatibility layer

### Phase 4: Full ICP-First Experience

- ICP as primary user experience
- Web2 as optional enhancement
- Advanced privacy controls

## Required Backend Functions

```rust
// User management
#[ic_cdk::update]
fn register_icp_user() -> Result<User, Error>

#[ic_cdk::query]
fn get_user_by_principal(principal: Principal) -> Option<User>

#[ic_cdk::update]
fn enable_web2_sync(uuid: String) -> Result<(), Error>

#[ic_cdk::update]
fn disable_web2_sync() -> Result<(), Error>

// Web2 synchronization
#[ic_cdk::update]
fn sync_to_web2(data: Web2SyncData) -> Result<(), Error>

#[ic_cdk::query]
fn get_web2_sync_status() -> Option<Web2SyncData>
```

## Privacy Considerations

### Data Minimization

- Only sync necessary data to Web2
- User controls what gets synchronized
- Default to ICP-only mode

### Privacy Levels

- **Level 1**: ICP-only (no Web2 footprint)
- **Level 2**: Hybrid (selective Web2 sync)
- **Level 3**: Full sync (existing Web2 users)

## Technical Challenges

### 1. **Cross-Platform Interactions**

- How do ICP users interact with Web2 users?
- Privacy implications of cross-platform features

### 2. **Data Consistency**

- Ensuring data consistency between ICP and Web2
- Handling conflicts in bidirectional sync

### 3. **Performance**

- Efficient synchronization mechanisms
- Minimizing cross-platform calls

## Success Metrics

- **User Adoption**: Percentage of users choosing ICP-first registration
- **Privacy**: Percentage of users staying ICP-only
- **Engagement**: Cross-platform feature usage
- **Performance**: Sync operation latency

## Dependencies

- Internet Identity integration
- StableBTreeMap user registry
- Neon database schema updates
- Frontend authentication flow updates

## Related Issues

- [Backend Functions Needed for Personal Canister Management](./BACKEND_FUNCTIONS_NEEDED.md)
- [Rename Binding to Neon Functions](./rename_binding_to_neon_functions.md)

## Notes

- This is a **future enhancement** - not part of MVP
- Current focus should remain on launching existing architecture
- Greenfield opportunity - no legacy migration concerns
- Aligns with Web3/ICP core values of privacy and decentralization

## APPENDIX I: Current Implementation Files and Flows

### Core Authentication Files

#### 1. NextAuth Configuration

**File**: `src/nextjs/auth.ts`

- **Purpose**: Main authentication configuration and provider setup
- **Key Components**:
  - Google OAuth provider configuration
  - GitHub OAuth provider configuration
  - Internet Identity custom provider implementation
  - Credentials provider for email/password
  - JWT and session callbacks
  - Database adapter configuration

#### 2. NextAuth API Routes

**File**: `src/nextjs/src/app/api/auth/[...nextauth]/route.ts`

- **Purpose**: API route handler for NextAuth endpoints
- **Function**: Exports NextAuth handlers for authentication endpoints

#### 3. Database Schema

**File**: `src/nextjs/src/db/schema.ts`

- **Purpose**: Database schema definitions for authentication tables
- **Key Tables**:
  - `users` - Core user data
  - `accounts` - Authentication provider accounts
  - `sessions` - Active user sessions
  - `verificationTokens` - Email verification tokens

#### 4. Frontend Authentication Components

**File**: `src/nextjs/src/components/onboarding/steps/sign-up-step.tsx`

- **Purpose**: User registration and sign-in UI
- **Features**: Google, GitHub, and email/password sign-in buttons

### Authentication Flow Details

#### Google Authentication Flow

1. **User Action**: Clicks "Sign in with Google"
2. **Frontend**: Calls `signIn('google')` from NextAuth
3. **NextAuth**: Redirects to Google OAuth consent screen
4. **Google**: User authenticates and grants permissions
5. **Google**: Redirects back with authorization code
6. **Backend**: NextAuth exchanges code for access token
7. **Backend**: Fetches user profile from Google API
8. **Backend**: Creates/updates user in database:
   ```sql
   INSERT INTO users (id, name, email, image) VALUES (google_sub, profile.name, profile.email, profile.picture);
   INSERT INTO accounts (userId, type, provider, providerAccountId) VALUES (google_sub, 'oauth', 'google', google_sub);
   ```
9. **Backend**: Creates JWT session token
10. **Frontend**: User redirected to dashboard with active session

**Key Values Stored**:

- `users.id` = Google's `sub` field
- `users.email` = Google profile email
- `users.name` = Google profile name
- `accounts.providerAccountId` = Google's `sub` field

#### Internet Identity Authentication Flow

1. **User Action**: Clicks "Sign in with Internet Identity"
2. **Frontend**: Calls `signIn('ii')` with principal and nonce
3. **Backend**: Validates nonce with ICP canister
4. **Backend**: Verifies principal signature
5. **Backend**: Checks for existing II account:
   ```sql
   SELECT * FROM accounts WHERE provider = 'internet-identity' AND providerAccountId = principal;
   ```
6. **If Existing**: Returns existing user
7. **If New**: Creates new user and account:
   ```sql
   INSERT INTO users (id) VALUES (generated_uuid);
   INSERT INTO accounts (userId, type, provider, providerAccountId) VALUES (generated_uuid, 'oidc', 'internet-identity', principal);
   ```
8. **Backend**: Creates JWT session with principal in token
9. **Frontend**: User redirected to dashboard

**Key Values Stored**:

- `users.id` = Generated UUID (not the principal)
- `users.email` = `NULL` (II users don't have email)
- `users.name` = `NULL` (II users don't have name)
- `accounts.providerAccountId` = ICP Principal (e.g., `"rdmx6-jaaaa-aaaah-qcaiq-cai"`)

#### Credentials Authentication Flow

1. **User Action**: Enters email/password and submits form
2. **Frontend**: Calls `signIn('credentials')` with email/password
3. **Backend**: Validates credentials against database
4. **Backend**: Checks for existing user:
   ```sql
   SELECT * FROM users WHERE email = provided_email;
   ```
5. **Backend**: Verifies password hash
6. **Backend**: Creates/updates account record:
   ```sql
   INSERT INTO accounts (userId, type, provider, providerAccountId) VALUES (user_id, 'credentials', 'credentials', email);
   ```
7. **Backend**: Creates JWT session
8. **Frontend**: User redirected to dashboard

**Key Values Stored**:

- `users.id` = Generated UUID
- `users.email` = User-provided email
- `users.name` = User-provided name
- `accounts.providerAccountId` = User's email address

### Dual Authentication Implementation

#### Account Linking Process

When a user signs in with a second provider:

1. **Backend**: Checks for existing account with same provider
2. **If Found**: Returns existing user (prevents duplicate accounts)
3. **If Not Found**: Creates new account record linked to existing user
4. **Result**: User can sign in with either provider

#### Example: Google → Internet Identity Linking

1. **User already has Google account**: `users.id = "google_sub_123"`
2. **User signs in with Internet Identity**: Principal `"rdmx6-jaaaa-aaaah-qcaiq-cai"`
3. **Backend**: Creates new account record:
   ```sql
   INSERT INTO accounts (userId, type, provider, providerAccountId)
   VALUES ('google_sub_123', 'oidc', 'internet-identity', 'rdmx6-jaaaa-aaaah-qcaiq-cai');
   ```
4. **Result**: Same user can now sign in with either Google or Internet Identity

### Database Relationships

```
users (1) ←→ (many) accounts
  ↓
allUsers (1) ←→ (1) users
```

- **One user** can have **multiple accounts** (Google + II + GitHub)
- **Each account** represents a different authentication method
- **Primary key** on `accounts(provider, providerAccountId)` prevents duplicates
- **Foreign key** `accounts.userId` links to `users.id`

### Session Management

- **JWT Strategy**: NextAuth uses JWT tokens instead of database sessions
- **Token Contents**: User ID, email, name, role, and ICP principal (if available)
- **Token Callbacks**: Custom logic to include ICP principal in JWT for II users
- **Session Persistence**: Tokens stored in HTTP-only cookies

### Key Implementation Notes

1. **ICP Principal Storage**: Stored in `accounts.providerAccountId` for II provider
2. **User ID Generation**: Google uses their `sub`, others use generated UUIDs
3. **Email Handling**: II users have `NULL` email, others have actual email
4. **Account Linking**: Automatic based on existing account lookups
5. **Session Strategy**: JWT-based for better performance and scalability

---

_This issue represents a significant architectural evolution that positions the application as a true Web3 platform while maintaining Web2 compatibility for users who need it._
