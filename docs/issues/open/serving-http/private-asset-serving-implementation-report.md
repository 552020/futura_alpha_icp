# Private Asset Serving Implementation Report

We implemented private asset serving through HTTP from canisters to frontend while preserving privacy.

## Why We Built This

The Next.js Image component was throwing errors when trying to display images from ICP due to unconfigured hostnames. The error was: `hostname "memory" is not configured under images in your next.config.js`. We needed a way to serve private assets directly from canisters to frontend while maintaining complete privacy and access control.

## What We Did

- Token-gated HTTP serving of private assets
- HMAC authentication with 3-minute TTL
- Integration with existing Futura permission system
- Support for asset variants (original, thumbnail, preview)
- Minimal state addition (only secret storage)

## URL Format

```
/asset/{memory_id}/{variant}?id={asset_id}&token={hmac_token}
```

## Solutions Considered

1. **Backend Proxy Call** - Next.js API calls canister, but backend principal is not the logged-in user (breaks privacy, adds latency)
2. **Temporary Endpoint** - User fetches bytes from ICP, uploads to temp Web2 endpoint, then loads from temp URL (double transfer, not scalable)
3. **Custom Wrapper with `<img>`** - Frontend calls canister directly with user's principal, converts bytes to blob URL (best privacy, but loses Next.js Image component features)
4. **`http_request` Method** - Canister serves assets directly via HTTPS, but HTTP gateway doesn't pass user principal (anonymous calls, needs token-based auth)

## ICP Information Flow

The frontend accesses canisters on the Internet Computer through an agent (like `@dfinity/agent`) or `dfx`, which connects to a boundary node. The boundary node exposes a normal HTTP API that translates HTTP requests into canister calls. The HTTP request body follows an ICP standard format containing the canister ID, function name, and arguments - not readable by a web server. The boundary node unpacks this body, makes the call on behalf of the frontend to the canister, receives the response, packs it into an HTTP response, and sends it back to the client. However, when using `http_request` for direct asset serving, the boundary node doesn't forward the user's principal to the canister, making all calls anonymous. This is why we need token-based authentication to maintain privacy and access control.

## ICP Information Flow vs Browser Needs

Browsers expect many HTML elements to load resources via direct HTTP URLs. The `src` attribute of `<img>`, `<video>`, `<audio>`, `<iframe>`, and `<script>` tags, as well as CSS `background-image: url(...)` and `@import` statements, all require direct HTTP addresses that browsers can fetch automatically. This conflicts with ICP's standard flow where frontend makes programmatic calls through agents.

The problematic ICP protocol URL that caused the Next.js error - this is the actual resource location format returned by ICP:

```
icp://memory/c6f07efb-4e4f-73c0-c6f0-0000000073c0/blob/b01288cc-fc1c-07a3-95f9-7cb46ae2b89bd0b4
```

This URL format is generated by our backend when creating asset references. The format `icp://memory/{memory_id}/blob/{asset_id}` is a protocol scheme that represents:

- `icp://` - Protocol identifier (we add this prefix in our backend code)
- `memory/{memory_id}` - The memory container where the asset lives
- `blob/{asset_id}` - The specific blob asset within that memory

This is not a real HTTP URL that browsers can fetch. It's an internal reference format that our system uses to identify assets stored in ICP canisters. When the frontend tries to use this as an `src` attribute, browsers reject it because they don't understand the `icp://` protocol scheme.

## The Solution: http_request Method

The `http_request` method bridges this gap by providing normal HTTPS URLs that browsers can fetch directly while maintaining privacy through token-based authentication. When a browser requests an asset URL like `https://canister.icp0.io/asset/memory123/thumbnail?token=...`, the boundary node routes it to the canister's `http_request` function, which verifies the token, checks permissions, and returns the asset data as a standard HTTP response. This allows browsers to load assets naturally while preserving the privacy model through stateless HMAC tokens.

## Sources

- [ICP Image Configuration Issue - Next.js Image Component](icp-image-configuration-nextjs.md)
